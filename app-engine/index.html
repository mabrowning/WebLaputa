<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="utf-8">
<script type="text/javascript" src="js/glMatrix-0.9.5.min.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;
    varying vec4 vPosition;

    uniform sampler2D uSampler;

    uniform float uMaterialShininess;

    uniform bool uShowSpecularHighlights;
    uniform bool uUseTextures;

    uniform vec3 uLightAmCol; 
    uniform vec3 uLightPos;
    uniform vec3 uLightSpCol;
    uniform vec3 uLightDiCol;


    void main(void) {
        vec3 lightWeighting;
		vec3 lightDirection = normalize(uLightPos - vPosition.xyz);
		vec3 normal = normalize(vTransformedNormal);

		/*
		float specularLightWeighting = 0.0;
		if (uShowSpecularHighlights) {
			vec3 eyeDirection = normalize(-vPosition.xyz);
			vec3 reflectionDirection = reflect(-lightDirection, normal);

			specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
		}
		*/

		float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);
		lightWeighting = uLightAmCol
//			+ uLightSpCol * specularLightWeighting
			+ uLightDiCol * diffuseLightWeighting;

        vec4 fragmentColor;
        if (uUseTextures) {
            fragmentColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        } else {
            fragmentColor = vec4(0.1, 0.6, 0.1, 1.0);
        }
        gl_FragColor = vec4(fragmentColor.rgb * lightWeighting, fragmentColor.a);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
//    uniform mat3 uNMatrix;


    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;
    varying vec4 vPosition;


    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
		gl_PointSize = 2.0;
        vTextureCoord = aTextureCoord;
//        vTransformedNormal = uNMatrix * aVertexNormal;
        vTransformedNormal = aVertexNormal;
    }
</script>
<script id="shader-fs-old" type="x-shader/x-fragment">
    precision mediump float;

    void main(void) {
        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }
</script>

<script id="shader-vs-old" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		gl_PointSize = 2.0;
    }
</script>

<script type="text/javascript">

var gl;
function initGL(canvas) {
	try {
		gl = canvas.getContext("experimental-webgl");
		gl.viewportWidth = canvas.width;
		gl.viewportHeight = canvas.height;
	} catch (e) {
	}
	if (!gl) {
		alert("Could not initialise WebGL, sorry :-(");
	}
}

DIR = {
	N:	0,
	E:	2,
	S:	4,
	W:	6
}
VOXEL = {
	AIR:		0, 
	DIRT:		1, 
	HALFBLOCK:	2, 
	WOOD:		3,
	PIT:		4,
}
var last = 5;
BLOCKS = {BLOCK:0,ARCH:0,RAMP:0}
for(blk in BLOCKS)
{
	for(dir in DIR)
	{
		VOXEL[blk+dir+"A"] = last++;
		VOXEL[blk+dir+"B"] = last++;
	}
}

function WLChunk(x,y,z,data)
{
	var chunksize = WLChunk.size;
	this.vboTop   = gl.createBuffer();
	this.vboTop.ibo   = gl.createBuffer();
	this.vboSides = gl.createBuffer();
	this.iboSides = gl.createBuffer();
	this.x = x * chunksize;
	this.y = y * chunksize;
	this.z = z * chunksize;
	this.hasmesh = this.rebuild(data);
};

WLChunk.prototype.getvoxel = function(x,y,z,data)
{
	if(x in data && y in data[x] &&z in data[x][y])
		return data[x][y][z];
	return VOXEL.AIR;
}

WLChunk.prototype.getheight =function(z,heights)
{
	for(i in heights)
		if (Math.abs(z - heights[i]) < 2 )
			return heights[i];
	return z-2;
}

WLChunk.prototype.addnorm = function(norms,pos,norm)
{
	var chunksize = WLChunk.size;

	//Hash the vertex position
	var i = pos.join("|");

	//Add or add the norm.
	if( i in norms)
		vec3.add(norms[i],norm);
	else
		norms[i] = norm;
	return i;
}


WLChunk.prototype.rebuild = function(data)
{
	var chunksize = WLChunk.size;
	var heights = new Array();
	for(xi=-1;xi<=chunksize;xi++)
	{
		var x = this.x + xi;
		heights[xi+1] = new Array();
		for(yi=-1;yi<=chunksize;yi++)
		{
			var y = this.y + yi;
			heights[xi+1][yi+1] = new Array();
			var b = this.getvoxel(x,y,this.z + chunksize,data);
			for(zi=chunksize-1;zi>=-1;zi--)
			{
				var z = this.z + zi;

				var lastb = b;
				b = this.getvoxel(x,y,z,data);
				if(b == VOXEL.DIRT && lastb != VOXEL.DIRT)
				{
					heights[xi+1][yi+1].push(zi+1); //zi+1 because the mesh is on the top of the block
				}
			}
		}
	}
	this.heights = heights;
	var norms = {}; //Will store hashed verex positions mapping to their unnormalized normals ;)
	var indices = new Array();
	for(x=1; x<heights.length-1; x++)
	{
		for(y=1; y<heights[x].length-1; y++)
		{
			for(i in heights[x][y])
			{
				var h = heights[x][y][i];
				/*
				This face(h) has neighors(voxels) with height of the following:

				+--+--+--+    6=w+nw+n+h/4  7=n+h/2 8=n+ne+e+h/4
				|nw| n|ne| 
				+--+--+--+    
				| w| h| e|    3=     w/h/2  4=  h   5=     h+n/2
				+--+--+--+ 
				|sw| s|se|
				+--+--+--+    0=w+sw+s+h/4  1=s+h/2 2=s+se+e+h/4
				*/

				var sw=this.getheight(h,heights[x-1][y-1]);
				var  w=this.getheight(h,heights[x-1][y  ]);
				var nw=this.getheight(h,heights[x-1][y+1]);
				var n =this.getheight(h,heights[x  ][y+1]);
				var ne=this.getheight(h,heights[x+1][y+1]);
				var  e=this.getheight(h,heights[x+1][y  ]);
				var se=this.getheight(h,heights[x+1][y-1]);
				var s =this.getheight(h,heights[x  ][y-1]);

				var qsw = 0.25*sw;
				var qnw = 0.25*nw;
				var qse = 0.25*se;
				var qne = 0.25*ne;
				var  qn = 0.25*n;
				var  qs = 0.25*s;
				var  qw = 0.25*w;
				var  qe = 0.25*e;

				var zp = new Array();
				var weights = 
				zp[0] = (w+sw+s+h) / 4;
				zp[1] = (qw+qe+qsw+qse+s+h) / 3;
				zp[2] = (e+se+s+h) / 4;
				zp[3] = (qsw+qnw+qs+qn+w+h) / 3;
				zp[5] = (qse+qne+qs+qn+e+h) / 3;
				zp[6] = (w+nw+n+h) / 4;
				zp[7] = (qw+qe+qnw+qne+n+h) / 3;
				zp[8] = (e+ne+n+h) / 4;
				zp[4] = (zp[0] + zp[1] + zp[2] + zp[3] + zp[5] + zp[6] + zp[7] +zp[8] + h)/9;

				var xp = new Array();
				xp[0] = xp[3] = xp[6] = x;
				xp[1] = xp[4] = xp[7] = x + 0.5;
				xp[2] = xp[5] = xp[8] = x + 1.0;

				var yp = new Array();
				yp[0] = yp[1] = yp[2] = y;
				yp[3] = yp[4] = yp[5] = y + 0.5;
				yp[6] = yp[7] = yp[8] = y + 1.0;

				/*
				This face is made up of the following triangles:
				+-+-+     6-7-8      |4/|6/|
				|/|/|	  |/|/|      |/5|/7|
				+-+-+ --> 3-4-5  --> +--+--+
				|/|/|     |/|/|      |0/|2/|
				+-+-+     0-1-2      |/1|/3|
				Triangles are indexed by vertex: 043, 014, 154, 125, 376, 347, 487, 458

				*/

				var tris = [ ];
				if ( Math.abs(zp[4] - zp[0]) < Math.abs(zp[1] - zp[3]) )
					tris = tris.concat([[0,1,3], [1,4,3]]);
				else
					tris = tris.concat([[0,4,3], [0,1,4]]);
				if ( Math.abs(zp[4] - zp[2]) < Math.abs( zp[1] - zp[5]) )
					tris = tris.concat([[1,5,4], [1,2,5]]);
				else
					tris = tris.concat([[1,2,4], [2,5,4]]);
				if ( Math.abs(zp[4] - zp[6]) < Math.abs(zp[3] -zp[7]) )
					tris = tris.concat([[3,7,6], [3,4,7]]);
				else
					tris = tris.concat([[4,6,3], [4,7,6]]);
				if ( Math.abs(zp[4] - zp[8]) < Math.abs(zp[5] - zp[7]) )
					tris = tris.concat([[5,8,7], [5,7,4]]);
				else
					tris = tris.concat([[4,8,7], [4,5,8]]);

				for(i in tris)
				{
					var tri = tris[i];
					var p0 = [xp[tri[0]], yp[tri[0]], zp[tri[0]]];
					var p1 = [xp[tri[1]], yp[tri[1]], zp[tri[1]]];
					var p2 = [xp[tri[2]], yp[tri[2]], zp[tri[2]]];
					var u = vec3.create();
					vec3.subtract(p1,p0,u);
					var v = vec3.create();
					vec3.subtract(p2,p0,v);
					var norm = vec3.cross(u,v);

					indices.push(this.addnorm(norms,p0,norm));
					indices.push(this.addnorm(norms,p1,norm));
					indices.push(this.addnorm(norms,p2,norm));
				}
			}
		}
	}

	//Build VBO for top mesh.
	var arrTop = new Array();
	var vcount = 0;
	var vIndices = {};
	for( norm in norms )
	{
		vIndices[norm] = vcount;

		var pos = norm.split("|");
		var x = parseFloat(pos[0]);
		var y = parseFloat(pos[1]);
		var z = parseFloat(pos[2]);

		arrTop.push(x+this.x);
		arrTop.push(z+this.z);
		arrTop.push(y+this.y);
		var norm = norms[norm];
		vec3.normalize(norm);
		arrTop.push(norm[0]);
		arrTop.push(norm[2]);
		arrTop.push(norm[1]);
		vcount++;
	}
	this.vboTop.vcount = vcount;
	gl.bindBuffer(gl.ARRAY_BUFFER, this.vboTop);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arrTop), gl.STATIC_DRAW);

	var arrTopInd = new Array();
	//Build Vertex indices
	var icount = 0;
	for( i in indices )
	{
		//Each ind is a hashed vertex. The mapping from hash to vertex index is vIndices
		arrTopInd.push(vIndices[indices[i]]);
		icount++;
	}
	this.vboTop.icount = icount;
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vboTop.ibo);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(arrTopInd), gl.STATIC_DRAW);

	//TODO: sides and bottoms
	this.vboSides.vcount = 0;
	gl.bindBuffer(gl.ARRAY_BUFFER, this.vboSides);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(), gl.STATIC_DRAW);

	return icount > 0 || this.vboSides.vcount > 0;
}
WLChunk.size = 16;

function WLWorld(size)
{
	this.xsize = size;
	this.ysize = size;
	this.zsize = size;

	var chunksize = WLChunk.size;

	this.xchunk = Math.floor((size - 1)/chunksize) + 1;
	this.ychunk = Math.floor((size - 1)/chunksize) + 1;
	this.zchunk = Math.floor((size - 1)/chunksize) + 1;

	var data = new Array();
	for(x=0;x<this.xchunk * chunksize ;x++)
	{
		data[x] = new Array();
		for(y=0;y<this.ychunk * chunksize;y++)
		{
			data[x][y] = new Array();
			for(z=0;z<this.zchunk * chunksize;z++)
			{
				cos = Math.cos(Math.PI/8)
				sin = Math.sin(Math.PI/8)
				xp = x - size/2
				yp = y - size/2;
				if( (xp*xp + yp*yp ) * cos * cos - z * z * sin * sin  < 0 )
				{

					if( z > size/2 + 1)
						data[x][y][z] = VOXEL.AIR;
					else if( z > size/2  && Math.random() > 0.1)
						data[x][y][z] = VOXEL.AIR;
					else
						data[x][y][z] = VOXEL.DIRT;
				}
				else
					data[x][y][z] = VOXEL.AIR
			}
		}
	}
	this.data = data;
	var chunk = new Array();
	this.meshes = new Array();
	for(x=0;x<this.xchunk;x++)
	{
		chunk[x] = new Array();
		for(y=0;y<this.ychunk;y++)
		{
			chunk[x][y] = new Array();
			for(z=0;z<this.zchunk;z++)
			{
				chunk[x][y][z] = new WLChunk(x,y,z,data);
				if(chunk[x][y][z].vboTop.icount > 0)
				{
					this.meshes.push(chunk[x][y][z].vboTop);
				}
			}
		}
	}
	this.chunks = chunk;
}

WLWorld.prototype.onupdateblock = function(x,y,z) 
{
	var xc = x/ WLChunk.size;
	var yc = y/ WLChunk.size;
	var zc = z/ WLChunk.size;
	var add = this.chunks[x][y][z].rebuild(this.data);
	if(chunk[x][y][z].vboTop.icount > 0)
	{
		this.meshes.push(chunk[x][y][z].vboTop);
	}
}


WLRenderer = function(world) {
	var fragmentShader = this.getShader("shader-fs");
	var vertexShader = this.getShader("shader-vs");

	this.program = gl.createProgram();

	gl.attachShader(this.program, vertexShader);
	gl.attachShader(this.program, fragmentShader);
	gl.linkProgram(this.program);

	if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
		alert("Could not initialise shaders");
	}

	gl.useProgram(this.program);

	this.aVertexPos = gl.getAttribLocation (this.program, "aVertexPosition");
	gl.enableVertexAttribArray(this.aVertexPos);
	this.aVertexNor = gl.getAttribLocation (this.program, "aVertexNormal");
	gl.enableVertexAttribArray(this.aVertexNor);


	this.uLightPos   = gl.getUniformLocation(this.program, "uLightPos");
	this.uLightAmCol = gl.getUniformLocation(this.program, "uLightAmCol");
	this.uLightSpCol = gl.getUniformLocation(this.program, "uLightSpCol");
	this.uLightDiCol = gl.getUniformLocation(this.program, "uLightDiCol");

	gl.uniform3f(this.uLightPos,   false, 40,40,40);
	gl.uniform3f(this.uLightAmCol, false, 0.7,0.7,0.6);
	gl.uniform3f(this.uLightSpCol, false, 1.0,1.0,1.0);
	gl.uniform3f(this.uLightDiCol, false, 0.9,0.9,0.8);

	this.uPMatrix   = gl.getUniformLocation(this.program, "uPMatrix");
	this.uMVMatrix  = gl.getUniformLocation(this.program, "uMVMatrix");

    this.mvMatrix   = mat4.create();
    this.tranMatrix = vec3.create();
	this.rotVec     = vec3.create();
	mat4.identity(this.mvMatrix);

    this.pMatrix  = mat4.create();

	gl.clearColor(0.0, 0.0, 0.0, 1.0);
	gl.enable(gl.DEPTH_TEST);
	gl.enable(gl.CULL_FACE);
	gl.cullFace(gl.BACK);
	gl.frontFace(gl.CW);

	this.world = world;

	this.keys = {}

	var that = this;

	document.addEventListener("keydown",   function(e){that.keydown(e)},   false);
	document.addEventListener("keyup",     function(e){that.keyup(e)},     false);
	document.addEventListener("mousedown", function(e){that.mousedown(e)}, false);
	document.addEventListener("mouseup",   function(e){that.mouseup(e)},   false);
	document.addEventListener("mousemove", function(e){that.mousemove(e)}, false);

	//gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 1000.0, this.pMatrix);
	gl.uniformMatrix4fv(this.uPMatrix, false, this.pMatrix);

	this.tranMatrix.set([0,-world.xsize,-world.xsize]);
	this.rotVec.set([-0.92, -0.66, 0]); //chosen arbitrarily by looking a good view.

	this.rend = new Date().getTime();

}

WLRenderer.prototype.keydown = function(e)
{
	this.keys[e.keyCode] = true;
}

WLRenderer.prototype.keyup = function(e)
{
	this.keys[e.keyCode] = false;
}

WLRenderer.prototype.mouseup = function(e)
{
	this.mousedrag = false;
	delete this.oldmouse;
	delete this.mousepos;
}

WLRenderer.prototype.mousedown = function(e)
{
	this.mousedrag = true;
}

WLRenderer.prototype.mousemove = function(e)
{
	if(this.mousedrag)
	{
		this.mousepos = [ e.clientX, e.clientY ];
	}
}


WLRenderer.prototype.getShader = function (id) {
	var shaderScript = document.getElementById(id);
	if (!shaderScript) {
		return null;
	}

	var str = "";
	var k = shaderScript.firstChild;
	while (k) {
		if (k.nodeType == 3) {
			str += k.textContent;
		}
		k = k.nextSibling;
	}

	var shader;
	if (shaderScript.type == "x-shader/x-fragment") {
		shader = gl.createShader(gl.FRAGMENT_SHADER);
	} else if (shaderScript.type == "x-shader/x-vertex") {
		shader = gl.createShader(gl.VERTEX_SHADER);
	} else {
		return null;
	}

	gl.shaderSource(shader, str);
	gl.compileShader(shader);

	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		alert(gl.getShaderInfoLog(shader));
		return null;
	}

	return shader;
}


WLRenderer.prototype.draw = function() {

	this.oldrend = this.rend;
	this.rend = new Date().getTime();
	var millielapsed = this.rend - this.oldrend;
	if(this.oldmouse)
	{
		var x = this.oldmouse[0] - this.mousepos[0];
		var y = this.oldmouse[1] - this.mousepos[1];
		if(x)
			this.rotVec[0] += x/200 //Yaw; 
		if(y)
		{
			this.rotVec[1] += y/200; //Pitch
			if(this.rotVec[1] >  Math.PI/2) this.rotVec[1] =  Math.PI/2;
			if(this.rotVec[1] < -Math.PI/2) this.rotVec[1] = -Math.PI/2;
		}

	}

	this.oldmouse = this.mousepos;

	var move = [0,0,0];
	if(this.keys[87]) //W
	{
		move[2] += Math.cos( this.rotVec[0] ) * Math.cos( -this.rotVec[1] );
		move[0] += Math.sin( this.rotVec[0] ) * Math.cos( -this.rotVec[1] );
		move[1] +=                              Math.sin( -this.rotVec[1] );

	}
	if(this.keys[83]) //S
	{
		move[2] -= Math.cos( this.rotVec[0] ) * Math.cos( -this.rotVec[1] );
		move[0] -= Math.sin( this.rotVec[0] ) * Math.cos( -this.rotVec[1] );
		move[1] -=                              Math.sin( -this.rotVec[1] );
	}
	if(this.keys[65]) //A
	{
		move[0] += Math.cos( this.rotVec[0] ) 
		move[2] -= Math.sin( this.rotVec[0] ) 
	}
	if(this.keys[68]) //D
	{
		move[0] -= Math.cos( this.rotVec[0] )
		move[2] += Math.sin( this.rotVec[0] ) 
	}
	if(this.keys[16]) //shift
	{
		move[2] += Math.cos( this.rotVec[0] ) * Math.sin( this.rotVec[1] );
		move[0] += Math.sin( this.rotVec[0] ) * Math.sin( this.rotVec[1] );
		move[1] +=                              Math.cos( this.rotVec[1] );
	}
	if(this.keys[32]) //space
	{
		move[2] -= Math.cos( this.rotVec[0] ) * Math.sin( this.rotVec[1] );
		move[0] -= Math.sin( this.rotVec[0] ) * Math.sin( this.rotVec[1] );
		move[1] -=                              Math.cos( this.rotVec[1] );
	}
	vec3.normalize(move);
	vec3.scale(move,0.05*millielapsed);

	vec3.add(this.tranMatrix,move);

	mat4.identity(this.mvMatrix);

	mat4.rotateX(this.mvMatrix,-this.rotVec[1]);
	mat4.rotateY(this.mvMatrix,-this.rotVec[0]);

	mat4.translate(this.mvMatrix,this.tranMatrix);
	gl.uniformMatrix4fv(this.uMVMatrix, false, this.mvMatrix);

	var world = this.world;

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	for(i in world.meshes)
	{
		var mesh = world.meshes[i];
		gl.bindBuffer(gl.ARRAY_BUFFER, mesh);
		gl.vertexAttribPointer(this.aVertexPos, 3, gl.FLOAT, false, 24, 0);
		gl.vertexAttribPointer(this.aVertexNor, 3, gl.FLOAT, false, 24, 12);

		//gl.drawArrays(gl.POINTS,0, mesh.vcount);


		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,mesh.ibo)
		gl.drawElements(gl.TRIANGLES,mesh.icount,gl.UNSIGNED_SHORT,0);
	}
	/*
	for(x=0;x<world.xchunk;x++)
	{
		for(y=0;y<world.ychunk;y++)
		{
			for(z=0;z<world.zchunk;z++)
			{
				var chunk = world.chunks[x][y][z];
				gl.bindBuffer(gl.ARRAY_BUFFER, chunk.vboTop);
				gl.vertexAttribPointer(this.aVertexPos, 3, gl.FLOAT, false, 24, 0);
				gl.vertexAttribPointer(this.aVertexNor, 3, gl.FLOAT, false, 24, 12);

				//gl.drawArrays(gl.POINTS,0, chunk.vboTop.vcount);


				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,chunk.vboTop.ibo)
				gl.drawElements(gl.TRIANGLES,chunk.vboTop.icount,gl.UNSIGNED_SHORT,0);

				//gl.bindBuffer(gl.ARRAY_BUFFER, chunk.vboSides);
				//gl.vertexAttribPointer(this.aVertexPos, 3, gl.FLOAT, false, 0, 0);
				//gl.drawArrays(gl.POINTS,0, chunk.vboSides.vcount);
			}
		}
	}
	*/
}
var renderer;
var world;

// shim layer with setTimeout fallback
window.requestAnimFrame = (function(){
  return  window.requestAnimationFrame       || 
		  window.webkitRequestAnimationFrame || 
		  window.mozRequestAnimationFrame    || 
		  window.oRequestAnimationFrame      || 
		  window.msRequestAnimationFrame     || 
		  function( callback ){
			window.setTimeout(callback, 1000 / 60);
		  };
})();

    function start() {

        var canvas = document.getElementById("webGL");
		initGL(canvas);
		world = new WLWorld(128);
        renderer = new WLRenderer(world);
		(function animloop(){
			  requestAnimFrame(animloop);
			  renderer.draw();
			})();
    }


</script>
	</head>
	<body onload="start();">
		<canvas id="webGL" style="border: none;" width="1000" height="1000" >
	</body>
</html>

